{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getBgColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.48605150214592274, 0.5309012875536481) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.3900*2., 1e-5);\nuv = rotate(uv, (0.4212 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0,"texture":{"src":"https://assets.unicorn.studio/images/h5aO9TguPCRl8emk1MPMBs1WTgu1/ChatGPT%20Image%20Feb%2011,%202026,%2005_48_37%20PM.jpg","sampler":"uCustomTexture"},"parentLayer":"5d43c3ef-d696-4efb-9cdb-a122b52cec1a","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) {\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec4 noiseTrail(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) {\nvec4 color = vec4(0);\nvec2 noise = bccNoiseDerivatives_XYBeforeZ(vec3((uv * vec2(aspectRatio, 1) - mouseDir / 8.0 - 0.5) * 250.0 * 0.3400, strength)).xy * strength * 0.25;\nvec2 distorted = (mouseDir + noise) * 0.4;\nuv -= distorted;\ncolor = texture(uTexture, uv);\ncolor.rgb = chromatic_aberration(color.rgb, uv, distorted * 0.3800 * 0.12);\nreturn color;\n}vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) {\nvec4 color = vec4(0);return noiseTrail(uv, mouseDir, strength, aspectRatio);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;\nfloat aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (0.3600 * 1.5);\nvec2 direction = angleToDir(angle);\nvec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 aspectVec = vec2(aspectRatio, 1.0);\nvec2 uv = vTextureCoord;\nvec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec;\nfloat dist = length(dir);\nif (dist > 0.0) {\ndir = dir / dist;\n} else {\ndir = vec2(1.0, 0.0);\n}float rad = 0.1100 * 0.4 * mix(aspectRatio, 1.0, 0.5);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec3 lastFrameColor = vec3(0);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0;\nvec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec;\nfloat distanceToLine = distance(correctedUv, closestPoint);float shrink = mix(0.5, 1.0, clamp(dist * 20.0, 0.0, 1.0));\nrad *= shrink;float s = smoothstep(rad, rad * 0.0000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.0000 * 0.03) + 0.0000 * 0.015, 0.0000);\nfloat blurRadius = 0.003;\nlastFrameColor = texture(uPingPongTexture, sampleUv).rgb * 0.4;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(-blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, blurRadius)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, -blurRadius)).rgb * 0.15;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nmouseColor = pow(mouseColor, vec3(2.2));\nlastFrameColor *= pow(0.0900, 0.2);\nfloat clampedDist = clamp(min(1.0, dist * 10.0) * s, 0.0, 1.0);\nvec3 draw = mix(lastFrameColor, mouseColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"mouse_trail"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradientMap","usesPingPong":false,"speed":0.15,"texture":false,"parentLayer":"be447e67-6e9f-442d-9c34-62a9fedb0a07","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0.5450980392156862, 0, 0.09411764705882353);\ncase 2: return vec3(0.8196078431372549, 0, 0.1607843137254902);\ncase 3: return vec3(1, 0.32941176470588235, 0.34509803921568627);\ncase 4: return vec3(1, 0.6666666666666666, 0.6470588235294118);\ncase 5: return vec3(1, 0.8941176470588236, 0.8862745098039215);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.2000;\ncase 2: return 0.4000;\ncase 3: return 0.6000;\ncase 4: return 0.8000;\ncase 5: return 1.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb)\n{\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin)\n{\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt(kCONEtoLMS*lin1);\nvec3 lms2 = safeCbrt(kCONEtoLMS*lin2);\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.02 * a * (1.0 - a);\nreturn kLMStoCONE*(lms*lms*lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 6 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat stopDelta = nextColorPosition - colorPosition;\nfloat mixFactor = clamp(stopDelta > 0.0001 ? (position - colorPosition) / stopDelta : 0.0, 0.0, 1.0);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(6 - 1);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat position = smoothstep(0., 1., luma(color.rgb)) * (0.5000 * 2.);\nfloat posOffset = (dot(vec2(0.5, 0.5).x, vec2(0.5, 0.5).y) + 0.2500 + 0.0001) * 2.;\nposition -= (uTime*0.01 + posOffset);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = clamp(animatedPos, 0.0, 1.0);vec3 gradientColor = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ngradientColor += dither;\nvec3 mixedColor = mix(color.rgb, gradientColor, 1.0000);color.rgb = mixedColor;\nfragColor = color;\n;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"gradient_map"},{"breakpoints":[],"aspectRatio":2.332928311057108,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"image","width":450,"widthMode":1,"height":192.89062500000003,"heightMode":2,"left":0.5,"top":0.5,"src":"https://assets.unicorn.studio/images/h5aO9TguPCRl8emk1MPMBs1WTgu1/95cd8a3c5389183d848b85c5734fff3b079bdb43-3214x1808.webp","imageNaturalSize":{"type":"Vec2","_x":1920,"_y":823},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float imageAspect = vec2(1920, 823).x / vec2(1920, 823).y;\nfloat canvasAspect = uArtboardResolution.x / uArtboardResolution.y;\nvec2 fitSize = vec2(\n(canvasAspect < imageAspect) ? uArtboardResolution.y * imageAspect : uArtboardResolution.x,\n(canvasAspect < imageAspect) ? uArtboardResolution.y : uArtboardResolution.x / imageAspect\n);\nvec2 offset = (uArtboardResolution - fitSize) * 0.5;\nvec2 adjustedPos = canvasPos + mouseOffset;\nimageUV = (adjustedPos - offset) / fitSize;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(1920, 823), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor.rgb = mix(vec3(luminance), color.rgb, 0.0000);color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":2.332928311057108}}},"id":"image"},{"breakpoints":[],"aspectRatio":1.5,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"hover","id":"04b09384-fdfb-442b-9899-754c527863e2","prop":"width","transition":{"delay":0,"ease":"easeInOutQuad","duration":1000},"progress":0,"rawProgress":0,"lastProgress":null,"value":1493.2124999999999,"triggerOnElement":1,"breakpoints":[],"uniformData":{"type":"1f","name":"uWidth","value":512}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"hover","id":"ce5d80bb-0874-4b6c-88cc-f905b3db353f","prop":"width","transition":{"delay":0,"duration":1000,"ease":"s=>s<.5?(1-Math.sqrt(1-(2*s)**2))/2:(Math.sqrt(1-Math.pow(-2*s+2,2))+1)/2"},"progress":0,"rawProgress":0,"lastProgress":null,"value":1493.2124999999999,"triggerOnElement":0,"breakpoints":[],"uniformData":{"type":"1f","name":"uWidth","value":512}}],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"axisTilt":0.06,"layerType":"image","width":1493.2124999999999,"widthMode":1,"height":995.4749999999999,"heightMode":2,"left":0.4779123263888889,"top":0.6485972222222223,"src":"https://assets.unicorn.studio/images/h5aO9TguPCRl8emk1MPMBs1WTgu1/ChatGPT%20Image%20Feb%2011,%202026,%2005_48_37%20PM_nobg_1770825042922.png","imageNaturalSize":{"type":"Vec2","_x":1536,"_y":1024},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;\nuniform float uWidth;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float absWidth = uWidth;\nfloat absHeight = 995.4750 * uArtboardResolution.y;if (1 == 2) {\nabsWidth = absHeight * 1.5000;\n} else if (2 == 2) {\nabsHeight = absWidth / 1.5000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.4779, 0.6486) * uArtboardResolution - getAnchorOffsets() * elementSizePx;vec2 centerPos = elementPosPx + (elementSizePx * 0.5);\nvec2 relPos = canvasPos - centerPos + mouseOffset;\nvec2 unrotatedRelPos = rotate2D(relPos, 0.0000 * -TAU);\nvec2 elementPos = unrotatedRelPos + (elementSizePx * 0.5);\nimageUV = elementPos / elementSizePx;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(1536, 1024), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0600 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.5}}},"id":"image1"},{"breakpoints":[],"aspectRatio":1.5,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":["7ed79c36-738b-4919-b0be-b3bcf2726664","5d43c3ef-d696-4efb-9cdb-a122b52cec1a","be447e67-6e9f-442d-9c34-62a9fedb0a07"],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"image","width":1240.5,"widthMode":1,"height":827,"heightMode":2,"left":0.5138888888888888,"top":0.49444444444444446,"src":"https://assets.unicorn.studio/images/h5aO9TguPCRl8emk1MPMBs1WTgu1/ChatGPT%20Image%20Feb%2010,%202026,%2010_21_32%20PM_nobg_1770754976994.png","imageNaturalSize":{"type":"Vec2","_x":1536,"_y":1024},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float absWidth = 1240.5000;\nfloat absHeight = 827.0000 * uArtboardResolution.y;if (1 == 2) {\nabsWidth = absHeight * 1.5000;\n} else if (2 == 2) {\nabsHeight = absWidth / 1.5000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.5139, 0.4944) * uArtboardResolution - getAnchorOffsets() * elementSizePx;vec2 centerPos = elementPosPx + (elementSizePx * 0.5);\nvec2 relPos = canvasPos - centerPos + mouseOffset;\nvec2 unrotatedRelPos = rotate2D(relPos, 0.0000 * -TAU);\nvec2 elementPos = unrotatedRelPos + (elementSizePx * 0.5);\nimageUV = elementPos / elementSizePx;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(1536, 1024), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 applyImageAdjustments(vec4 color) {color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getSourceOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\nreturn applyImageAdjustments(color);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getSourceOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.5}},"compositeShader":{"fragmentShader":"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0);uv -= pos;vec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}","vertexShader":"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"},"compositeUniforms":{"resolution":{"name":"uResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"opacity":{"name":"uOpacity","type":"1f","value":1},"mousePos":{"name":"uMousePos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}},"id":"image2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0.59,"texture":false,"parentLayer":"7ed79c36-738b-4919-b0be-b3bcf2726664","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) {\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) {\nvec4 color = vec4(0);\nfloat zMix = strength;\nvec2 distorted = mouseDir * 0.4 * 0.0000;\nuv -= distorted;\ncolor = texture(uTexture, uv);\ncolor.rgb = chromatic_aberration(color.rgb, uv, distorted * 0.1400 * 0.12);\ncolor = mix(vec4(vec3(0, 0, 0), 0.0000), color, zMix);\nreturn color;\n}vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) {\nvec4 color = vec4(0);return revealTrail(uv, mouseDir, strength);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;\nfloat aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (1.0000 * 1.5);\nvec2 direction = angleToDir(angle);\nvec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 aspectVec = vec2(aspectRatio, 1.0);\nvec2 uv = vTextureCoord;\nvec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec;\nfloat dist = length(dir);\nif (dist > 0.0) {\ndir = dir / dist;\n} else {\ndir = vec2(1.0, 0.0);\n}float rad = 0.3200 * 0.4 * mix(aspectRatio, 1.0, 0.5);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec3 lastFrameColor = vec3(0);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0;\nvec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec;\nfloat distanceToLine = distance(correctedUv, closestPoint);float shrink = mix(0.5, 1.0, clamp(dist * 20.0, 0.0, 1.0));\nrad *= shrink;float s = smoothstep(rad, rad * 0.2000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.3100 * 0.03) + 0.3100 * 0.015, 0.3100);\nfloat blurRadius = 0.003;\nlastFrameColor = texture(uPingPongTexture, sampleUv).rgb * 0.4;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(-blurRadius, 0.0)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, blurRadius)).rgb * 0.15;\nlastFrameColor += texture(uPingPongTexture, sampleUv + vec2(0.0, -blurRadius)).rgb * 0.15;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nmouseColor = pow(mouseColor, vec3(2.2));\nlastFrameColor *= pow(0.8500, 0.2);\nfloat clampedDist = clamp(min(1.0, dist * 10.0) * s, 0.0, 1.0);\nvec3 draw = mix(lastFrameColor, mouseColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"mouse_trail1"}],"options":{"name":"Untitled project","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"wGxXRtA646287X6sCXiz"}